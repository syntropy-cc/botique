"""
Template selector

Selects appropriate textual template based on semantic similarity.

Uses semantic analysis of slide descriptions to select the best matching template
within each template hierarchy level.

Location: src/templates/selector.py
"""

import re
from typing import Dict, List, Tuple

from .library import TemplateLibrary
from .textual_templates import TextualTemplate


class TemplateSelector:
    """Selects textual template based on semantic similarity"""
    
    def __init__(self):
        """Initialize template selector"""
        self.library = TemplateLibrary()
    
    def select_template(
        self,
        module_type: str,
        purpose: str,
        copy_direction: str,
        key_elements: List[str],
        persona: str,
        tone: str,
        platform: str,
    ) -> Tuple[str, str, float]:
        """
        Select appropriate template based on semantic similarity.
        
        Uses the slide description (purpose + copy_direction) generated by
        the Narrative Architect to select the best matching template.
        
        Args:
            module_type: High-level type (hook, problem, insight, solution, value_prop, transition, cta)
            purpose: Slide purpose from Narrative Architect
            copy_direction: Narrative guidance from Narrative Architect
            key_elements: Key elements of the slide
            persona: Brief persona
            tone: Brief tone
            platform: Brief platform
        
        Returns:
            Tuple of (template_id, justification, confidence)
        """
        # Map narrative module types to template module types
        template_module_types = self._map_module_type_to_template_types(module_type)
        
        # Get candidate templates from all relevant template types
        candidates = []
        for template_module_type in template_module_types:
            candidates.extend(self.library.get_templates_by_module_type(template_module_type))
        
        if not candidates:
            raise ValueError(f"No template found for module_type: {module_type}")
        
        # Build slide description for semantic analysis
        slide_description = self._build_slide_description(
            purpose=purpose,
            copy_direction=copy_direction,
            key_elements=key_elements,
        )
        
        # Calculate semantic similarity scores for each candidate
        scores = []
        for template in candidates:
            score = self._calculate_semantic_similarity(
                template=template,
                slide_description=slide_description,
                persona=persona,
                tone=tone,
            )
            scores.append((template.id, score))
        
        # Select template with highest score
        scores.sort(key=lambda x: x[1], reverse=True)
        best_template_id, best_score = scores[0]
        
        # Generate justification
        justification = self._generate_justification(
            template_id=best_template_id,
            score=best_score,
            persona=persona,
            tone=tone,
        )
        
        return (best_template_id, justification, best_score)
    
    def _build_slide_description(
        self,
        purpose: str,
        copy_direction: str,
        key_elements: List[str],
    ) -> str:
        """
        Build comprehensive slide description for semantic analysis.
        
        Combines purpose and copy_direction from Narrative Architect
        to create a rich description of what the slide should communicate.
        
        Args:
            purpose: Slide purpose
            copy_direction: Narrative guidance
            key_elements: Key elements
        
        Returns:
            Combined description string
        """
        description_parts = [purpose, copy_direction]
        if key_elements:
            description_parts.append(" ".join(key_elements))
        return " ".join(description_parts)
    
    def _map_module_type_to_template_types(self, module_type: str) -> List[str]:
        """
        Map narrative module type to template module types.
        
        Narrative module types are: hook, problem, insight, solution, value_prop, transition, cta
        Template module types are: hook, insight, solution, example, cta
        
        Args:
            module_type: Narrative module type
        
        Returns:
            List of template module types to search
        """
        mapping = {
            "hook": ["hook"],
            "problem": ["insight"],  # Problems often use insights or data
            "insight": ["insight"],  # Insights use insight templates
            "solution": ["solution"],  # Solutions use solution templates
            "value_prop": ["example", "solution"],  # Value props often use examples or solutions
            "transition": ["insight"],  # Transitions can use insights
            "cta": ["cta"],  # CTAs use CTA templates
        }
        return mapping.get(module_type, ["insight"])  # Default to insight if unknown
    
    def _calculate_semantic_similarity(
        self,
        template: TextualTemplate,
        slide_description: str,
        persona: str,
        tone: str,
    ) -> float:
        """
        Calculate semantic similarity score (0.0-1.0).
        
        Uses multiple matching strategies:
        1. Semantic description matching (primary - 50%)
        2. Function matching (25%)
        3. Tone matching (15%)
        4. Keyword matching (10%)
        
        Args:
            template: Template to score
            slide_description: Combined slide description from Narrative Architect
            persona: Brief persona
            tone: Brief tone
        
        Returns:
            Similarity score between 0.0 and 1.0
        """
        score = 0.0
        
        # Normalize text for comparison
        slide_text = self._normalize_text(slide_description)
        template_description = self._normalize_text(template.semantic_description or "")
        template_function = self._normalize_text(template.function or "")
        template_tone = self._normalize_text(template.tone or "")
        brief_tone = self._normalize_text(tone)
        
        # 1. Semantic description matching (50% weight)
        if template_description:
            description_score = self._text_similarity(slide_text, template_description)
            score += description_score * 0.5
        
        # 2. Function matching (25% weight)
        if template_function:
            function_score = self._text_similarity(slide_text, template_function)
            score += function_score * 0.25
        
        # 3. Tone matching (15% weight)
        if template_tone and brief_tone:
            tone_score = self._text_similarity(template_tone, brief_tone)
            score += tone_score * 0.15
        
        # 4. Keyword matching (10% weight)
        template_keywords = template.keywords or []
        if template_keywords:
            keyword_score = self._keyword_similarity(slide_text, template_keywords)
            score += keyword_score * 0.1
        
        # Ensure score is between 0.0 and 1.0
        return min(score, 1.0)
    
    def _normalize_text(self, text: str) -> str:
        """
        Normalize text for comparison.
        
        Args:
            text: Input text
        
        Returns:
            Normalized text (lowercase, punctuation removed, whitespace normalized)
        """
        # Convert to lowercase
        text = text.lower()
        # Remove punctuation (keep alphanumeric and spaces)
        text = re.sub(r'[^\w\s]', ' ', text)
        # Normalize whitespace
        text = re.sub(r'\s+', ' ', text).strip()
        return text
    
    def _text_similarity(self, text1: str, text2: str) -> float:
        """
        Calculate text similarity using word overlap and position.
        
        Uses Jaccard similarity (intersection over union) weighted by
        word frequency and position importance.
        
        Args:
            text1: First text
            text2: Second text
        
        Returns:
            Similarity score between 0.0 and 1.0
        """
        if not text1 or not text2:
            return 0.0
        
        words1 = set(text1.split())
        words2 = set(text2.split())
        
        if not words1 or not words2:
            return 0.0
        
        # Jaccard similarity (intersection over union)
        intersection = len(words1.intersection(words2))
        union = len(words1.union(words2))
        
        if union == 0:
            return 0.0
        
        base_similarity = intersection / union
        
        # Boost score if there are multiple matching words
        # (indicates stronger semantic match)
        if intersection > 1:
            boost = min(0.2, intersection * 0.05)
            base_similarity = min(1.0, base_similarity + boost)
        
        return base_similarity
    
    def _keyword_similarity(self, text: str, keywords: List[str]) -> float:
        """
        Calculate keyword matching score.
        
        Args:
            text: Text to search in
            keywords: List of keywords to match
        
        Returns:
            Score between 0.0 and 1.0 based on keyword matches
        """
        if not keywords:
            return 0.0
        
        normalized_text = self._normalize_text(text)
        normalized_keywords = [self._normalize_text(kw) for kw in keywords]
        
        matches = sum(1 for kw in normalized_keywords if kw in normalized_text)
        return matches / len(normalized_keywords)
    
    def _generate_justification(
        self,
        template_id: str,
        score: float,
        persona: str,
        tone: str,
    ) -> str:
        """
        Generate justification for template selection.
        
        Args:
            template_id: Selected template ID
            score: Similarity score
            persona: Brief persona
            tone: Brief tone
        
        Returns:
            Justification string
        """
        template = self.library.get_template(template_id)
        if not template:
            return f"Template {template_id} selected (score: {score:.2f})"
        
        structure_preview = template.structure[:50]
        if len(template.structure) > 50:
            structure_preview += "..."
        
        return (
            f"{persona} in {tone} â†’ {template.function} "
            f"({structure_preview}) - similarity: {score:.2f}"
        )
